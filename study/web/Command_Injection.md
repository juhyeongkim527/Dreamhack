# 서론

웹 애플리케이션을 개발하다보면, 어떤 기능에 대해서는 일일히 스스로 코드를 작성하기 보다 이미 설치된 소프트웨어를 사용하는 것이 편리할 때가 있다.

예를 들어, 업로드 디렉토리에 있는 파일들의 이름을 출력하는 웹 애플리케이션을 만든다고 가정해보자.

이때, 만약 업로드 디렉토리의 파일들을 조회하는 코드를 직접 작성하는 것보다 시스템에 내장되어 있는 `ls` 유틸리티를 사용하는 것이 훨씬 간편할 것이다.

이렇게 다양한 웹 애플리케이션 제작용 언어는 위에서 살펴본 `ls` 유틸리티와 같이 **시스템에 내장되어있는 프로그램들을 호출할 수 있는 함수를 지원한다.**

각 언어별 시스템 함수로는 **PHP**의 `system`, **Node JS**의 `child_process`, **Python**의 `os.system`이 있다.

이러한 함수는 C의 `system` 함수와 같이, 함수에 전달된 인자를 쉘 프로그램에 전달하여 명령어를 실핸한다.

예를 들어, PHP의 `system("cat /etc/passwd")`를 호출하면, 쉘 프로그램으로 `cat /etc/passwd` 명령어를 실행한 것과 같다.

시스템 함수를 사용하면 이미 설치된 소프트웨어들을 쉽게 이용할 수 있다는 큰 장점이 존재하지만, 해당 함수의 인자를 쉘 프로그램에 전달한다는 점에서 치명적인 취약점으로 이어질 수 있다.

# Command Injection

**Injection**은 악의적인 데이터를 프로그램에 입력하여 이를 시스템 명령어, 코드, 데이터베이스 쿼리 등으로 실행되게 하는 기법을 말한다,

**이 중 이용자의 입력이 시스템 함수의 인자로 전달되어, 이 입력이 쉘에 전달되어 시스템 명령어로 실행하게 하는 취약점을 Command Injection이라고 한다.**

예를 들어 파이썬으로 개발된 웹 애플리케이션에서 입력한 임의 IP에 ping을 전송하고 싶은 경우 `os.system("ping [user-input])"`을 사용하고, 

임의 파일을 읽고싶다면 `os.system("cat [user-input]")`등의 형태로 시스템 함수를 사용할 수 있다.

그런데 이렇게 **이용자의 입력이 인자에 포함되어 시스템 함수가 호출될 때, 이용자의 입력을 제대로 검사하지 않으면 임의 명령어가 실행될 수도 있다.**

왜냐하면, 리눅스 쉘 프로그램에는 지원되는 다양한 **메타 문자**가 존재하기 때문이다. 아래에서 쉘의 메타 문자들을 살펴보자.

### ``` `` ``` : 명령어 치환

``` `` ``` 안에 들어있는 명령어를 실행한 결과로 치환된다.

```
$ echo `echo theori`
theori
```

### `$()` : 명령어 치환

`$()` 안에 들어있는 명령어를 실행한 결과로 치환된다. 위와 다른 점은 `$()` 내부에 중복하여 겹쳐서 사용할 수 있다는 것이다. ex) `echo $(echo $(echo theori))`

```
$ echo $(echo theori)
theori
```

### `$$` : 명령어 연속 실행 (Logical And)

두 개의 명령어를 연결하여 사용하고, 앞 명령어에서 에러가 발생하지 않는 경우만 Short-circuit evaluation에 의해 뒷 명령어가 실행된다.

```
$ echo hello && echo theori
hello
theori
```

### `||` : 명령어 연속 실행 (Logical OR)

두 개의 명령어를 연결하여 사용하고, 앞 명령어에서 에러가 발생하는 경우만 Short-circuit evaluation에 의해 뒷 명령어가 실행된다.

```
$ cat / || echo theori
cat: /: Is a directory
theori
```

### `;` : 명령어 구분자

한 줄에 여러개의 명령어를 연결하여 사용할 수 있다. `;`은 단순히 명령어를 구분하기 위해 사용하며, 앞 명령어의 에러 유무에 상관없이 뒷 명령어가 실행된다.

```
$ echo hello ; echo theori
hello
theori
```

### `|` : 파이프

앞 명령어의 실행 결과가 뒷 명령어의 입력으로 들어간다. 명령어 치환은 출력 결과를 **다른 명령어의 인자**로 전달하고, 파이프는 출력 결과를 **다른 명령어의 입력**으로 전달하는 차이점이 있다고 하는데, 이건 더 공부해봐야겠다.

```
$ echo id | /bin/sh
uid=1001(theori) gid=1001(theori) groups=1001(theori)
```

주목할 점은, `&&`, `||`, `;`, `|` 등을 사용하면 여러 개의 명령어를 연속으로 실행시킬 수 있다는 것이다.

따라서 공격자는 메타 문자를 통해 임의 명령어를 추가적으로 실행하도록 조작하여 쉘을 획득할 수 있다. 아래에서 실습 모듈으로 실제로 간단한 공격을 테스트해보자.

## [실습 모듈](https://learn.dreamhack.io/labs/5ec7d68c-136c-4eef-8901-7f091790e9d0)

<img width="774" alt="image" src="https://github.com/user-attachments/assets/fbfc7f5a-876f-43d1-b2a4-330f5d76775a">

```
query = request.form.get('query', '')
cmd = f'ping -c 3 {query}'
output = subprocess.check_output(['/bin/sh', '-c', cmd], timeout=5)
```

서버의 코드는 위와 같다. 폼에서 입력 받은 `query`값을 저장해준 후, 해당 값을 넣어서 `cmd`를 `"ping -c 3 {query}"`로 선언해준다. `-c 3`은 `ping`을 3번 보내는 것이라고 생각하면 된다.

그리고 `subprocess.check_output()` 함수는 인자로 전달된 `리스트`에 존재하는 외부 쉘 명령어를 실행하고, 출력 결과를 가져오는 함수이다.

인자로는 **실행할 명령어와 옵션**을 전달해주고, `timeout` 이내에 명령어 실행이 끝나지 않으면 에러가 발생하게 된다.

인자로 전달한 리스트는 `['/bin/sh', '-c', cmd]` 인데, `'/bin/sh` 쉘을 실행할 때 `-c` 옵션을 통해 `cmd` 문자열을 쉘의 명령어로 전달하는 것으로 해석하면 된다.

그럼 취약점에 대해서 생각해보자. 

쉘의 명령어이자 시스템 함수의 인자로 전달되는 `cmd` 문자열은 사용자가 입력한 폼의 값을 통해 가져온다.

그런데 사용자의 입력에 메타문자나 명령어가 포함되어 있는지 검사하는 부분이 없기 때문에, Command Injection 취약점이 존재하게 된다.

그냥 일반적인 로컬호스트 IP 주소인 `127.0.0.1`을 전달해주면 아래와 같이 `ping`의 실행 결과가 잘 나온다. 참고로, `8.8.8.8`은 구글의 public DNS 서버의 IP이다.

<img width="785" alt="image" src="https://github.com/user-attachments/assets/c8b13aa9-b024-4044-8385-288b124ea382">

근데 여기서 메타 문자를 통해 쉘에서 `flag` 파일을 출력하는 명령어인 `cat flag`가 실행되도록 `cmd`를 조작하면 Command Injection 공격을 통해 플래그를 획득할 수 있을 것이다.

방법은 여러가지가 있는데 `;`, `|`, `||`를 사용하여 아래와 같이 작성할 수 있다.

`; cat flag`, `|| cat flag`, `| cat flag`

`&&`를 쓰려면, 앞의 `ping`에서 에러가 발생하면 안되기 때문에 IP 주소를 함께 전달해서 `ping`이 에러없이 실행되도록 `127.0.0.1 && cat flag`로 작성해줘야 한다.

<img width="775" alt="image" src="https://github.com/user-attachments/assets/ee814c9e-3c2a-4d25-b6d8-6d08d9b6fcb1">

<img width="756" alt="image" src="https://github.com/user-attachments/assets/a14b5bcb-91ab-4980-80ba-5fd9ea5662f9">

반대로, `||`은 IP 주소 없이 써야하고 정상적으로 `ping`이 동작하면 뒤 명령어가 수행되지 않아서 플래그가 출력되지 않는다.

<img width="785" alt="image" src="https://github.com/user-attachments/assets/891a111e-e44e-4e63-ab0c-05896cdc544e

<img width="769" alt="image" src="https://github.com/user-attachments/assets/287c5d69-620b-4c92-92ee-1390f5ac826e">

나머지는 `ping`에서 오류가 발생해도 다음 명령어에 상관이 없기 때문에 IP 주소 없이 작성해줘도 되고, 참고로 `|` 파이프를 통해 `cat flag`에 입력이 전달되지 않는 이유는 `cat`은 파일 이름을 인자로 받고, `|`는 뒷 명령어의 인자가 아닌 입력으로 전달되기 때문이다.

## 정리

이용자의 입력을 적절한 검사 없이 시스템 함수의 명령어로 사용할 때 발생하는 **Command Injection**에 대해 알아보았다.

해당 취약점이 발생하는 원리는 단순하지만, 공격에 사용되면 웹 애플리케이션에 임의 명령어를 실행할 수 있기 때문에 공격 파급력이 높다.

해당 취약점을 막기 위해서는 입력 값에 대해 **메타 문자의 유무를 철저히 검사**하거나, **시스템 메타 문자를 해석하지 않고 문자 자체로 다루는 함수를 사용**해야 한다.
