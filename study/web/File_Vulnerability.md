# 서론

많은 현대 웹 서비스에는 텍스트로만 전달하기 힘든 정보를 전달하기 위해 **이미지나 문서 등의 파일 업로드 기능**이 존재한다.

이러한 파일 공유 서비스를 개발할 때, 이용자가 업로드한 파일을 **데이터베이스에 저장하는 것보다는 서버의 파일 시스템에 저장하는 것이 개발하기 쉽고, 관리 효율도 높다.**

대부분 파일 자체는 파일 시스템에 저장하고, 파일의 메타데이터를 데이터베이스에 저장하는 방식을 사용한다.

그러나 업로드 파일을 파일 시스템에 저장하는 것은, 임의 파일이 다운로드 되는 취약점이나, 악성 쉡셸 파일을 업로드하여 임의 코드를 실행할 수 있는 취약점을 발생시키기도 한다.

**파일 업로드와 관련해서 발생하는 취약점**을 `File Upload Vulnerability`, **파일 다운로드와 관련해서 발생하는 취약점**을 `File Download Vulnerability`라고 한다.

미리 간단히 설명하면 **파일 업로드 취약점**은 파일 시스템 상 **임의 경로에 원하는 파일을 업로드**하거나, **악성 확장자를 갖는 파일을 업로드할 수 있을 때** 발생하는 취약점이다.

이 취약점은, 원하는 시스템 커맨드를 실행하는 원격 코드 실행 취약점을 유발할 수 있다.

그리고 **파일 다운로드 취약점**은 공격자가 웹 서비스의 파일 시스템에 존재하는 **임의 파일을 다운받을 수 있을 때 발생**하는 취약점이다.

이 취약점은, 설정 파일, 패스워드 파일, 데이터베이스 백업본 등을 다운로드 하여 민감한 정보를 탈취하여 2차 공격을 수행할 수 있다.

그럼 이제 더 자세히 두 취약점에 대해서 살펴보자.

# File Upload Vulnerability

**파일 업로드 취약점(File Upload Vulnerability)** 은 웹 서비스를 통해 이용자의 파일을 **서버의 파일 시스템에 업로드하는 과정에서 발생하는 취약점**이다.

이 취약점은 **이용자가 업로드될 파일의 이름을 임의로 정할 수 있을 때** 발생한다.

파일 이름에 이용자가 입력한 문자열을 그대로 사용하거나, 이용자의 이메일, 닉네임 등을 포함시키는 등의 소스 코드 패턴이 해당 취약점을 발생시킬 수 있다.

파일 업로드 취약점은 크게 **Path Traversal**과 **악성 파일 업로드**로 분류된다.

## 1. Path Traversal

파일 업로드를 허용하는 대부분의 서비스는 보안을 위해 특정 디렉토리에만 업로드를 허용한다.

만약 이러한 제한이 존재하지 않는다면, 악의적인 이용자가 **웹 서버의 소스 코드나 서버에 있는 중요 시스템 파일을 덮어 쓸 위험이 있다.** Path Traversal 취약점은 이 점에 집중한다.

Path Traversal 취약점은 **업로드에 존재하는 위와 같은 디렉토리 제약을 우회하여, 임의 디렉토리에 파일을 업로드할 수 있는 취약점**이다.

아래는 파일 업로드 기능에 Path Traversal 취약점이 존재하는 코드이다.

```
from flask import Flask, request
app = Flask(__name__)
@app.route('/fileUpload', methods = ['GET', 'POST'])
def upload_file():
	if request.method == 'POST':
		f = request.files['file']
		f.save("./uploads/" + f.filename)
		return 'Upload Success'
	else:
		return """
		<form action="/fileUpload" method="POST" enctype="multipart/form-data">
			<input type="file" name="file" />
			<input type="submit"/>
		</form>
		"""
if __name__ == '__main__':
	app.run()
```

`/fileUpload` 엔드포인트에서는 `POST` 요청을 받으면, 클라이언트가 전송한 파일을 `./uploads` 디렉토리에 저장한다.

그런데 이용자가 업로드한 파일의 이름인 `f.filename`을 그대로 사용하기 때문에, 공격자가 파일 이름을 임의로 조작하면 Path Traversal 취약점에 노출될 수 있다.

예를 들어, 파일 이름에 `../`과 같은 디렉토리를 나타내는 메타문자를 사용하면, `./uploads` 디렉토리를 벗어나 상위 디렉토리에도 파일을 업로드할 수 있다.

예를 들어, 파일 이름을 `../ex.py`로 정한 후 업로드하면, `./uploads/../app.py` 에 파일이 업로드되게 되는데, 

이렇게 되면 `uploads`의 상위 디렉토리에 저장하게 되고, 해당 디렉토리에 `app.py` 파일이 존재한다면, 업로드하는 파일로 해당 파일을 덮어쓰게 될 수 있다.

만약 서버에 존재하던 `app.py` 파일이 서버에서 실행되는 파일이었다면, 이용자가 `app.py` 파일을 덮어서 서버에서 악성 쉘 코드가 실행되도록 공격할 수 있을 것이다.

실제로 아래와 같이 `filename`을 `../hack.py`로 설정하여 `HTTP Request`를 요청하면 `./uploads`의 상위 디렉토리에 파일이 저장될 것이다.

```
POST /fileUpload HTTP/1.1
Host: storage.dreamhack.io
Origin: https://storage.dreamhack.io
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary20y3eoLVSNf9Ns5i
------WebKitFormBoundary20y3eoLVSNf9Ns5i
Content-Disposition: form-data; name="file"; filename="../hack.py"
Content-Type: text/plain
[malicious file content]
------WebKitFormBoundary20y3eoLVSNf9Ns5i--
```

위 요청을 전송한 후, `./uploads` 디렉토리의 상위 디렉토리로 이동하여 `ls -lR` 명령어를 입력하면 상위 디렉토리에 `hack.py` 파일이 저장된 것을 확인할 수 있다.

참고로, `ls -lR`은 `-l(long)` 옵션과 `-R(Recursive)` 옵션이 결합되어, 현재 디렉토리와 모든 하위 디렉토리의 파일 정보를 long format으로 출력하는 명령어이다.

```
$ ls -lR
-rw-r--r--  1 dreamhack  staff  461  1 30 21:52 app.py
-rw-r--r--  1 dreamhack  staff  431  1 30 22:12 hack.py
drwxr-xr-x  3 dreamhack  staff   96  1 30 21:31 uploads
./uploads:
total 8
-rw-r--r--  1 dreamhack  staff   13  1 30 21:31 test.txt
```

## 2. 악성 파일 업로드

악성 파일 업로드 취약점은 이용자가 파일을 업로드할 때, 이를 제대로 검사하지 않아서 발생하는 취약점을 뜻한다.

### 웹 셸

웹 서버는 `.php`, `.jsp`(JavaServer Pages), `.asp`(Active Server Pages)와 같은 확장자 파일을 **Common Gateway Interface(CGI)**로 실행하고, 그 결과를 이용자에게 반환한다.

**CGI**는 웹 브라우저에서 동적인 컨텐츠를 처리하기 위해서, **외부 프로그램(스크립트 또는 애플리케이션)을 실행하고 그 결과를 웹 브라우저에 반환하기 위한,** 웹 서버와 외부 프로그램 사이의 Interface를 제공하는 프로토콜이라고 생각하면 된다.

아래는 이용자가 요청한 파일의 확장자가 정규표현식 `".+\.ph(p[3457]?|t|tml)$"`를 만족하면, PHP 엔진인 `x-httpd-php`로 핸들링하게 하는 `Apache` 설정 파일이다.

`Apache`는 웹 페이지를 클라이언트(웹 브라우저)에게 제공하기 위해 사용되는 오픈소스 웹 서버 소프트웨어라고 이해하고 넘어가자.

```
<FilesMatch ".+\.ph(p[3457]?|t|tml)$">
    SetHandler application/x-httpd-php
</FilesMatch>
```
---

참고로, 확장자를 해석해보면, `.`은 하나의 문자를 나타내며, `+`는 앞의 패턴이 1번 이상 반복되는 것을 의미하기 때문에 파일 이름을 뜻한다.

그리고, `\.`은 문자 `.` 자체를 의미하고, `(p[3457]? | t | tml)`에서 `p[3457]?`는 `p` 뒤에 `3,4,5,7` 문자가 0번 또는 1번 나타날 수 있음(`?`)을 의미하고,

`t`와 `tml`은 OR로 연결되어 있다. `$`는 패턴의 끝을 나타낸다.

따라서, `example.php3` 또는 `example.phtml` 등의 파일 이름이 가능하다.

---

이용자가 요청한 파일이 해당 정규 표현식을 만족하면 PHP 엔진인 `x-httpd-php`는, php 요청한 파일을 실행하고 그 결과를 반환한다.

많은 웹 서버들이 `php` 파일에 대해 위와 같은 핸들링을 지원한다.

**따라서 공격자가 임의의 `php` 소스 파일을 `.php` 확장자로 업로드하고, `GET` 요청을 보낼 수 있다면 `CGI`에 의해 해당 코드가 실행되도록 할 수 있다.**

### 악의적인 웹 리소스

웹 브라우저는 **파일의 확장자**나 **HTTP Response의 `Content-Type`에 따라** 요청을 다양하게 처리한다.

만약 요청한 파일의 확장자가 `.html`이거나, 반환된 `Content-Type` 헤더가 `text/html`일 경우 응답은 **HTML 엔진**으로 처리된다.

또 파일의 확장자가 `.png`, `jpg`등의 이미지 확장자이거나, `Content-Type`이 `image/png`일 경우에는 이미지로 렌더링된다.

만약 이용자가 `https://dreamhack.io/uploads/my_file.html`라는 URL에 접근하는데, 공격자가 서버에 악성 스크립트가 삽입된 `my_file.html`를 업로드할 수 있다면,

브라우저는 이를 HTML로 해석하기 때문에 악성 스크립트가 실행되는 `XSS` 공격으로 이어질 수 있다.

# File Download Vulnerability

파일 다운로드 취약점은 웹 서비스를 통해 파일 시스템에 존재하는 파일을 내려 받는 과정에서 발생하는 보안 취약점이다.

해당 취약점은 **이용자가 다운로드할 파일의 이름을 임의로 정할 수 있을 때 발생한다.**

웹 서비스는 이용자가 업로드한 파일을 다운로드 받거나, 이미지를 불러올 때 특정 디렉토리에 있는 파일만 접근하도록 해야한다.

**Path Traversal**을 이용한 파일 다운로드 취약점은, 파일 이름을 직접 입력 받아 임의 디렉토리에 있는 파일을 다운로드 받을 수 있는 취약점을 말한다.

아래는 파일 다운로드 취약점이 자주 발생하는 URL 패턴이다.

- `https://vulnerable-web.dreamhack.io/download/?filename=notes.txt` : URL로 `filename`을 지정할 수 있는 경우, 임의의 파일을 원하는대로 다운받을 수 있다.

- `https://vulnerable-web.dreamhack.io/download/?filename=../../../../../../etc/passwd` : `../`을 연속으로 사용하여 `root directory`에 접근한 후 `/etc/passwd` 파일을 다운받을 수 있다.

- `https://vulnerable-web.dreamhack.io/images.php?fn=6ed0dd02806fa89e233b84f4.png` : 이미지 관련 기능을 처리하는 `images.php` 파일에서 파라미터인 `fn`을 지정할 수 있는 경우, 임의의 이미지를 원하는대로 불러올 수 있다.

그럼 아래에서 실습 모듈을 통해 직접 파일 취약점을 확인해보자.

# [실습 모듈](https://learn.dreamhack.io/labs/b33e7dbb-3beb-4658-9f46-ae14adf90238)

## 1. File Upload Vulnerability

<img width="804" alt="image" src="https://github.com/user-attachments/assets/15ed57f3-7b1b-4e8b-af57-b8b91bc58f10">

```
<?php
if(!empty($_FILES['file'])){
  $filename = "user_uploaded_file_".time();
  $ext = pathinfo($_FILES['file']['name'], PATHINFO_EXTENSION);
  $path = "./uploads/" . $filename . "." . $ext;
  
  if(move_uploaded_file($_FILES['file']['tmp_name'], $path)) {
    return true; // upload success
  } else {
    return false; // upload fail
  }
}
?>
```

위 코드는 이미지의 모듈을 구성하는 코드이다.

가장 앞 부분의 `$_FILES`는 PHP에서 파일 업로드와 관련된 정보를 담고 있는 글로벌 배열(`array`)이다. 해당 배열의 `file` 키값이 비어있지 않는다면 아래의 로직이 실행된다.

`$_FILES`의 예시는 아래와 같다.

```
$_FILES = array(
    'file' => array(
        'name' => 'example.txt',
        'type' => 'text/plain',
        'tmp_name' => '/tmp/phpYzdqkD',
        'error' => 0,
        'size' => 12345
    )
);
```

그럼 돌아와서 먼저, 파일 이름을 지정하는 `$filename` 변수를 보면, `"user_uploaded_file_"` 문자열과 1970-1-1 부터 경과된 시간을 나타내는 `time()` 값을 연결하여 저장한다.

참고로, php에서 `$`는 변수를 뜻하고, `.`은 문자열을 연결하는 연산자를 나타낸다.

**이 코드에서 알 수 있는 점은, 모듈에서 File Name을 조작해줘도 서버에서 저장할 `filename`을 이용자의 입력 값과 상관없이 임의로 설정하기 때문에 `Path Traversal` 공격은 불가능한 것을 알 수 있다.**

`$ext`는 `path_info()` 함수를 통해 파일에서 `PATHINFO_EXTENSION`인 확장자를 추출하여 저장하는 변수이며, `$path`는 파일이 저장될 경로를 나타낸다.

그리고 `move_uploaded_file()` 함수를 통해, 임시 위치에 저장된 파일을 `$path` 경로로 이동시켜 저장한다. 

해당 코드에서 파일 이름을 임의로 지정할 수 없어 **Path Traversal** 취약점은 존재하지 않지만, 악성 파일을 업로드하고 실행하는 것은 가능하다.

따라서, **악성 파일 업로드** 취약점을 활용해볼 수 있다.

### 1. 웹 셸 업로드

파일 이름(`$filename`) 자체는 이용자가 입력한 값으로 저장하지 않지만, 확장자(`$ext`)는 이용자가 입력한 파일 이름에서 추출하기 때문에 `.php` 파일을 업로드하여 실행하게 할 수 있다.

아래와 같은 웹 셸 `.php` 파일을 File Content에 작성하고 File Name에 `example.php`를 작성해보면 아래와 같이 `.php` 확장자를 가지는 웹 셸이 업로드 되어있는 것을 확인할 수 있다.

여기서는 `"php detected"`가 출력된 것을 보아 서버에서 검증이 발생한 것을 알 수 있지만, 만약 서버에서 검증이 없었다면 셸이 실행될 수 있을 것이다.

```
<?php
  system("ls");
  system($_GET[x]);
?>
```

<img width="832" alt="image" src="https://github.com/user-attachments/assets/8cded570-ee6a-4bd3-b6cc-a936e520fbb4">

<img width="808" alt="image" src="https://github.com/user-attachments/assets/4bc66f43-8b78-4389-8f0a-57329b4b0de9">

### 2. Stored XSS 시도

웹 셸과 유사하게 **Stored XSS**를 통해, 서버에 악성 스크립트를 저장하고 이용자가 이 악성 스크립트가 포함된 게시물을 조회할 때, 악성 스크립트가 실행되도록 할 수 있다.

참고로, 웹 셸인 `.php`와 달리 File Content를 랜더링 할 때, 다른 검증이 없다면 페이지와 내용을 HTML 문서를 나타내는 `text/html` 타입으로 랜더링하기 때문에, `.html` 확장자를 써주지 않아도 브라우저에서 이를 HTML 문서로 해석하여 스크립트를 실행할 수 있다.

그래서 위 코드에서는 `.js` 확장자에 대한 처리가 없고, 일반적으로 `text/html` 타입으로 렌더링하기 때문에 `.js`로 전달해서 `<script>` 없이 `alert(1);`만 전달해줬을 때 스크립트가 실행되지 않는 이유이다. 

그럼 `<script>alert(1);</script>` 코드를 File Content에 작성해주고, File Name에 구분을 위해 `example.html`을 작성해준 후 업로드하면, 아래와 같이 `.html` 확장자를 가지는 스크립트가 업로드 되어있는 것을 확인할 수 있다.

<img width="820" alt="image" src="https://github.com/user-attachments/assets/9d76a98d-4366-4447-bb6a-3df088db350e">

<img width="800" alt="image" src="https://github.com/user-attachments/assets/9cb44b54-5069-40b9-b570-3d6691bdb5d2">

그리고 업로드된 스크립트를 클릭해보면, 아래와 같이 `alert(1);`이 수행되는 것을 확인할 수 있다.

<img width="448" alt="image" src="https://github.com/user-attachments/assets/3fb222be-60cd-49f5-b42f-15c0e163e3c6">

만약 이 스크립트가 악성 스크립트였다면, 이용자가 이 게시물(스크립트)을 조회할 때 공격자가 의도한 악성 스크립트가 실행될 것이다.

## 2. File Download Vulnerability 

<img width="836" alt="image" src="https://github.com/user-attachments/assets/f1d8bbef-bd74-43ec-ab5a-92cb85d2a1a6">

```
# ...
Secret = os.environ("Secret")
# ...
@app.route("/download")
def download():
    filename = request.args.get("filename")
    content = open("./uploads/" + filename, "rb").read()
    return content
# ...
```

위 코드는 실습 모듈에 대한 구현 코드이다.

코드를 보면, `"Secret"`이라는 환경 변수에 저장된 값을 저장한 `Secret` 변수값을 파일 다운로드 취약점을 통해 획득해야한다.

참고로, bash 쉘에서 `export Secret=저장값`을 통해 환경 변수를 설정한다.

그럼 코드를 다시 살펴보면, 앞의 파일 업로드 취약점과 달리 `GET` 요청에서 이용자가 입력한 `filename`의 파라미터를 통해, 일치하는 파일을 가져와서 내용을 읽어준다.

따라서, **Path Traversal** 취약점이 존재하고, 이를 통해 `/home/dreamhack/.bash_history`에 저장된 환경 변수를 설정했던 bash쉘 커맨드 명령어 히스토리나, `/proc/self/environ`에 존재하는 환경변수 값을 읽어서 `Secret` 변수에 저장된 값을 읽을 수 있을 것이다.

아래와 같이 `../../../proc/self/environ`를 입력해서 `environ` 파일을 읽거나,

<img width="837" alt="image" src="https://github.com/user-attachments/assets/cfcc34c1-88b0-4280-8550-0b48ccc882a5">

아래와 같이 `../../../home/dreamhack/.bash_history`를 입력해서 환경 변수를 설정했던 bash쉘 커맨드 명령어 히스토리를 읽을 수 있다.

<img width="837" alt="image" src="https://github.com/user-attachments/assets/0ae10638-18c6-42ea-8ab7-cd741986230c">

# 마치며

해당 파일 취약점들은 발생 원리는 단순하지만, 공격에 사용되면 웹 애플리케이션에 임의 명령어를 실행하거나 중요 파일을 탈취할 수 있는 매우 치명적인 취약점이다.

**파일 업로드 취약점**을 막기 위해서는, **Path Traversal을 막기 위해 업로드 디렉토리를 웹 서버에서 직접 접근할 수 없도록** 하거나, **웹 셸을 막기 위해 업로드 디렉토리에서는 `CGI`가 실행되지 않도록** 해야 한다.

또한 업로드된 파일 이름을 그대로 사용하지 않는 방법으로는 `basepath`와 같은 함수를 통해 파일 이름을 검증하는 방법이 있고,

웹 셸을 막기 위해서는 허용할 확장자를 명시하여 그 외의 확장자가 업로드될 수 없도록 하는 방법도 있다.

그리고 **파일 다운로드 취약점**을 막기 위해서는 요청된 파일 이름을 `basepath`와 같은 함수를 통해 검증하거나, 

파일 이름과 일대일 매핑되는 key를 만들어, 이용자로부터 파일 이름이 아닌 key를 요청하도록 해야한다.
