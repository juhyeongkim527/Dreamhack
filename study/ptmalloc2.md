# Memory Allocator

운영체제의 핵심 역할 중 하나는 한정된 메모리 자원을 각 프로세스에 효율적으로 배분하는 일이다. 모든 프로세스는 실행 중에 메모리를 동적으로 할당하고 해제하며, 이 과정이 매우 빈번하게 일어난다.

따라서, OS의 `Memory Allocator`는 이러한 메모리의 할당과 해제를 매우 빠르고 효율적으로 이루어 지도록 하는 것이 중요하다.

이를 위해 OS의 Memory Allocator는 특수한 알고리즘으로 구현되며, 몇몇 소프트웨어는 자체적으로 직접 구현한 더욱 최적화된 Memory Allocator를 가지기도 한다.

Memory Allocator의 종류는 알고리즘에 따라 다양한데, 리눅스는 `ptmalloc2`, 구글은 `tcmalloc`, 페이스북이나 파이어폭스는 `jemalloc`를 사용한다. 지금 공부할 종류는 리눅스의 `ptmalloc2`이다.

ptmalloc는 어떤 메모리가 해제되면, 해제된 메모리의 특징을 기억하고 있다가, 비슷한 메모리 할당 요청이 발생하면 빠르게 가지고 있던 메모리들의 특징을 통해 적절한 메모리를 반환해준다. 

이를 통해, 메모리 할당 **속도**를 높일 수 있고, 한정된 메모리 공간을 효율적으로 사용할 수 있게 된다.

`ptmalloc2`는 동적 메모리를 관리하는 리눅스의 핵심 알고리즘이기 때문에 과거부터 다양한 공격 기법이 연구되었고, 이에 따라 새로운 보호 기법도 계속 탄생하였다.

따라서 `ptmalloc2`가 구현된 `GLibc` 버전에 따라 보호 기법이 다르기 때문에, 이에 따른 유효 공격 기법에 큰 차이가 존재한다.

이번 글에서는 `Ubuntu 18.04 64-bit(Glibc 2.27버전)`을 기준으로 취약점과 이에 따른 공격 기법을 설명할 것이다. 특히 `tcache`와 관련된 공격 기법을 간단히 살펴볼 것이며, `ptmalloc2`와 관련된 공격 기법은 매우 다양하고 버전에 따라서도 다르기 때문에 나중에 더 공부해볼 것이다.

## ptmalloc2(pthread malloc 2)

`ptmalloc2`는 `dlmalloc`을 개선한 `ptmalloc`의 두 번째 버전이다. 편하게 `ptmalloc2`를 `ptmalloc`이라고 부를 것이다. 앞에서 말했듯이 리눅스의 Memory Allocator이며 `Glibc`에 구현되어 있다.

ptmalloc의 구현 목표는 **메모리의 효율적인 관리**이다. 따라서 이 큰 목표를 달성하기 위해 아래의 핵심 3가지 세부 목표를 가진다.

### 1. 메모리 낭비 방지

메모리의 동적 할당과 해제는 매우 빈번하게 발생한다. 그런데 컴퓨터의 전체 메모리 공간은 한정되있기 때문에 새로운 공간을 무한히 할당할 수는 없다.

따라서, ptmalloc은 메모리 할당 요청이 발생하면, 먼저 해제된 메모리 공간 중에 재사용할 수 있는 공간이 있는지 탐색한다.

그 후 해제된 메모리 공간 중에서 요청된 크기와 같은 크기의 메모리 공간이 있다면 이를 그대로 재사용하게 한다. 또한, 작은 크기의 할당 요청이 발생했을 때, 해제된 메모리 공간 중 매우 큰 메모리 공간이 있으면 그 영역을 나누어 주기도 한다.

### 2. 빠른 메모리 재사용

운영체제가 프로세스에게 할당하는 **가상 메모리 공간**은 매우 크기 때문에, 사용 가능한(해제된) 메모리 공간을 탐색하기 위해 처음부터 끝까지 탐색하면 매우 시간이 오래걸린다.

따라서, 특정 메모리 공간을 해제한 이후에 이를 빠르게 재사용하려면 해제된 메모리 공간의 주소를 기억하고 있어야 한다.

이를 위해 ptmalloc은 메모리 공간을 해제할 때, `tcache` 또는 `bin`이라는 Linked-List에 해제된 메모리 공간의 정보를 저장해둔다.

**`tcache`와 `bin`은 여러 개가 정의되어 있으며, 각각은 서로 다른 크기의 메모리 공간들을 저장한다. 이러한 특징 때문에 특정 크기의 메모리 할당 요청이 발생했을 때, 그 크기와 관련된 저장소만 탐색하면 되므로 더욱 효율적으로 공간을 재사용할 수 있다.**

### 3. 메모리 단편화 방지

컴퓨터 과학의 메모리 관리 이론에서 `Internal Fragmentation`과 `External Fragmentation`를 관리하고 줄이는 것은 매우 중요한 과제이다.

`Internal Fragmentation`은 프로세스에게 일정 크기의 메모리가 할당되어 있는데, 실제 프로세스의 데이터가 점유하는 공간이 할당된 메모리의 크기에 비해 적어서, 사용하지 않는 빈 공간이 발생하는 경우를 말하며,

`External Fragmentation`은 여러 프로세스에게 할당된 메모리 공간들 사이에 한 프로세스에게 할당하기는 힘든 애매하게 작은 공간이 발생하는 경우이다.

이 두 단편화 때문에 메모리 공간 전체에서 사용되지 않는 공간이 많아보이지만, 실제로 프로세스에게 할당할 메모리 공간이 부족하게 되는 상황이 생길 수 있다.

따라서, ptmalloc은 단편화를 줄이기 위해 **정렬(Alignment)**, **병합(Coalescence)**, **분할(Split)** 방법을 사용한다. 

### 정렬(Alignment)

64비트 아키텍처에서 ptmalloc은 메모리 공간을 `16바이트` 단위로 할당해준다. 사용자가 어떤 크기의 메모리 공간을 요청하면, 그보다 조금 크거나 같은 16바이트 단위의 메모리 공간을 제공한다.

예를 들어, 사용자가 4바이트를 요청하면 16바이트 메모리 공간을 할당해주고, 17바이트를 요청하면 32바이트 메모리 공간을 할당해준다.

이렇게 되면 `Internal Fragmentation`은 발생하지만, 최대 발생할 수 있는 `Internal Fragmentation`은 한번 요청당 `15바이트`로 `External Fragmentation`에 비해 훨씬 작기 때문에 해당 방법으로 메모리 공간을 할당한다.

공간을 정렬하지 않고, 프로세스가 요청하는 만큼 할당할 수 있다면 모든 데이터가 연속적으로 할당되어 외부 단편화를 최소화할 수 있을 것 같아 보인다. 

***그러나 공간을 해제하고 재사용할 때, 정확히 같은 크기의 할당 요청이 발생할 확률보다 비슷한 크기의 요청이 발생할 확률이 높다.*** 

따라서 비슷한 크기의 요청에 대해서는 모두 같은 크기의 공간을 반환해야 해제된 청크들의 재사용률을 높이고, 외부 단편화도 줄일 수 있다.

### 병합(Coalescence), 분할(Split)

또한, ptmalloc은 특정 조건을 만족하는 상황에서 해제된 공간들을 병합하기도 한다. 병합으로 생성된 큰 공간은 그 공간과 같은 크기의 요청에 의해, 또는 그보다 작은 요청에 의해 분할되어 재사용된다.

잘게 나뉜 영역을 병합하고, 필요할 때 구역을 다시 설정함으로써 해제된 공간의 재사용률을 높이고, 외부 단편화를 줄일 수 있다.











