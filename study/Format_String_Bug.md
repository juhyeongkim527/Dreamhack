# Format String Bug

C에는 문자열을 다루는 여러 함수들이 존재하는데, 이 중 `printf, scanf, fprintf, fscanf` 함수의 이름이 `f(formatted)`로 끝나고 문자열을 다루는 함수라면 포맷스트링을 처리하는 함수들이다.

이 함수들을 포맷 스트링을 채울 값들을 `레지스터`나 `스택`에서 가져오는데, 함수 내부에 **`포맷 스트링이 필요로 하는 인자의 개수`와 `함수에 전달된 인자의 개수`를 비교하는 루틴이 존재하지 않는다.**

예를 들어, `printf("Value: %d %d %d\n");`라는 코드를 보자. 여기서 `포맷 스트링이 필요로 하는 인자의 개수`는 3개인데, `함수에 전달된 인자의 개수`는 없기 때문에 이를 비교하지 않고, 그냥 레지스터나 스택에서 인자를 가져오게 된다. 

이 특징 때문에 만약 포맷스트링을 사용자가 임의로 입력할 수 있다면, 사용자가 레지스터나 스택의 값을 원하는대로 읽어올 수 있고 다양한 포맷스트링을 활용하여 원하는 레지스터나 스택의 위치에 임의의 값을 쓰는 것도 가능하다.

# Format String

포맷 스트링은 아래와 같은 형식을 가진다.

- `%[parameter][flags][width][.precision][length]type`

여기서 우리가 중요하게 볼 점은 `paramter, width, type`이 있다.

## `type` 또는 `specifier` : 형식 지정자

인자를 어떻게 사용할지 지정하는 자리이다.

| 형식 지정자 | 설명                             |
|--------------|----------------------------------|
| `d`          | 부호있는 10진수 정수             |
| `s`          | 문자열                           |
| `x`          | 부호없는 16진수 정수             |
| `n`          | 인자에 현재까지 사용된 문자열의 길이를 저장 |
| `p`          | `void`형 포인터                  |

## `width` : 너비 지정자 

최소 너비를 지정해준다. 치환되는 문자열이 이 값보다 짧을 경우 공백 문자를 패딩해준다.

| 너비 지정자 | 설명 |
|-|-|
|`정수`|정수의 값만큼을 최소 너비로 지정한다.|
|`*`|인자의 값 만큼을 최소 너비로 지정한다.|

아래의 예제를 보며 `%n`의 쓰임과 `*`의 쓰임에 대해서 알아보자.

```
printf("%s%n: hi\n", "Alice", &num);  // "Alice: hi", num = 5
printf("%*s: hello\n", num, "Bob");   // "  Bob: hello"
```

여기서 첫번째 `printf`를 보면, 인자로 `%s`에는 `"Alice"`를 전달하고, `%n`에는 `&num`을 전달한다. `%n`은 우리가 인자에 현재까지 사용된 문자열의 길이를 저장하는 형식 지정자라고 했다.

따라서, `"Alice"`의 문자열 길이는 `5`이기 때문에 `num` 변수에는 `5`가 저장되게 된다. 이후, `printf("%*s: hello\n", num, "Bob");`에서는 `*`을 통해 인자로 전달한 `num`의 길이만큼 너비를 지정하게 되어 `"  Bob"`으로 출력된다.

`%n`을 쓰는 이유는, 포맷스트링의 인자가 사용자의 입력에 영향을 받는다면 실제 바이너리를 실행하여 입력을 받기 전에는 포맷 스트링의 길이를 알 수 없다.

따라서, `%n`을 사용한다면, 사용자가 만약 `"Alice"`보다 훨씬 긴 문자를 입력했더라도 아래의 `printf("%*s: hello\n", num, "Bob");`에서 바로 위의 문장과 정렬되서 출력할 수 있게 된다.

## `paramter`

참조할 인자의 `인덱스`를 지정한다. 인덱스는 `1`부터 시작하고 이 필드의 끝은 `$`로 표기해야 하며, **인덱스의 범위를 전달된 인자의 갯수와 비교하지 않는다.**

`printf("%2$d, %1$d\n", 2, 1);  // "1, 2"`

# 포맷 스트링 버그 예시

사용자가 포맷 스트링을 직접 입력할 수 있을 때 공격자는 **레지스터와 스택의 값을 읽거나, 임의 주소 읽기 및 쓰기를 할 수 있게 된다.**

```
// fsb_auth.c
#include <stdio.h>
int main(void) {
    int auth = 0x42424242;
    char buf[32] = {0, };
    
    read(0, buf, 32);
    printf(buf);
    
    // make auth to 0xff
}
```

해당 바이너리를 살펴보면, `printf`의 포맷 스트링으로 사용되는 `buf`를 사용자가 직접 입력할 수 있다. 참고로 `int printf(const char *format, ...);`가 기본형이다.

여기서 `auth`는 아래의 이미지와 같이 `buf - 0x4`의 주소에 위치하는데 `auth`의 값을 `0xff`로 덮어쓰려면 어떤 값을 입력해줘야 할까?

<img width="547" alt="image" src="https://github.com/user-attachments/assets/79091f12-422f-485f-a94f-6bc96505bb41">










