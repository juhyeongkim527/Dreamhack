# Out of Bounds

배열의 `index` 처리에서 발생하는 취약점이다. 크기가 미리 정해져 있는 배열의, 기존 크기를 벗어나는 `index` 요소에 참조하는 경우 발생할 수 있다. 

운이 좋으면 `Segmentation Fault`와 같이 프로그램의 비정상 종료로 그치지만, 컴파일러가 경고를 띄워주지 않기 때문에 어떤 경우에는 임의의 다른 메모리 영역에 접근할 수 있기 때문에 치명적인 취약점이 될 수 있다.

정리하면, 배열의 인덱스에 접근할 때 **인덱스 값이 음수이거나 배열의 길이를 벗어나는 경우** 발생한다. 컴파일러나 프로세스는 인덱스와 배열의 자료형에 따라, 어떤 요소(주소)에 접근할지만 계산할 뿐, **계산한 주소가 배열 범위 안에 있는지는 판단하지 않는다.**

따라서, 만약 사용자가 배열 참조에 사용되는 인덱스를 임의 값으로 조정할 수 있다면, 배열의 주소로부터 특정 오프셋에 있는 메모리의 값을 임의로 참조하거나 수정할 수 있게 되는 OOB 취약점이 발생한다.

## Example

```
// Name: oob.c
// Compile: gcc -o oob oob.c

#include <stdio.h>

int main() {
  int arr[10];

  printf("In Bound: \n");
  printf("arr: %p\n", arr);
  printf("arr[0]: %p\n\n", &arr[0]);

  printf("Out of Bounds: \n");
  printf("arr[-1]: %p\n", &arr[-1]);
  printf("arr[100]: %p\n", &arr[100]);

  return 0;
}
```

위의 바이너리를 보면, `int`형 변수 10개를 요소로 하는 배열 `arr`를 선언하고, `arr`, `arr[0]`, `arr[-1]`, `arr[100]` 의 주소를 출력한다.

여기서 중요한 점은 앞에서 말했듯이 `gcc` 컴파일러는 인덱스에 따른 요소의 주소만 계산할 뿐, 해당 주소가 배열의 범위에 속하는지는 판단하지 않기 때문에 프로그램이 정상적으로 실행된다.

해당 바이너리를 실행하면 아래와 같은 결과를 확인할 수 있다.

```
$ gcc -o oob oob.c
$ ./oob
In Bound:
arr: 0x7ffebc778b00
arr[0]: 0x7ffebc778b00

Out of Bounds:
arr[-1]: 0x7ffebc778afc
arr[100]: 0x7ffebc778c90
```

일단 배열 `arr`의 주소와 `arr[0]`의 주소는 같기 때문에 같게 나오고, `Out of Bounds:` 아래를 보면, 배열의 범위를 넘어서는 `arr[-1]`과 `arr[100]`의 주소도 오류없이 출력되는 것을 알 수 있다.

주소를 계산해보면, 먼저 `arr[0] - arr[-1] = 0x4`, `arr[100] - arr[0] = 0x190 = 100 x 4` 로 `int` 형의 오프셋과 일치하는 것을 알 수 있고 컴파일러는 인덱스에 따른 주소 계산만 적절히 수행해주는 것을 알 수 있다.
