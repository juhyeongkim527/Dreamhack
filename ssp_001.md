# 문제 풀이 방법
```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}
int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break
                case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```

위는 해당 문제의 c 소스코드이다.

코드를 보면 `get_shell()` 함수가 존재하는데 이 함수의 주소를 알아낸 후 `return_address`에 주소를 대입하여 쉘을 획득하는 익스플로잇 방식으로 문제를 풀이하면 될 것이다.

일단 해당 문제는 'i386' 아키텍처를 사용하고, `checksec` 명령어로 파일의 보안 정보를 살펴보면 `Stack Canary found`가 발생하므로,   
익스플로잇 과정에서 canary를 알아내서 값을 그대로 넣어줘야한다. 

그리고 소스코드를 보면 stack에 아래의 변수들이 사용되었는데, 해당 변수들의 위치와 크기를 `gdb`를 통해 파악하며 스택 프레임 구조를 그려봄으로서 canary에 접근할 방법을 찾았다.

- `unsigned char box[0x40] = {};`   : 64byte 크기
- `char name[0x40] = {};`           : 64byte 크기
- `char select[2] = {};`            : 2byte 크기
- `int idx = 0`                     : 4byte 크기 
- `name_len = 0`                    : 4byte 크기

## gdb 실행파일 분석

1. 먼저 gdb로 해당 파일을 실행하면 아래와 같은 디스어셈블 화면이 나오는데, 여기서 `rep stosd dword ptr es:[edi], eax` 명령어는 `es:[edi]`가 가리키는 4byte 공간의 주소에 `eax`값을 반복하여(`rep`) 저장하는(`stosd`) 명령어이고, 한번 수행될때마다 `ecx` 값이 1씩 감소하여 `ecx`값이 `0x0`이 되면 다음 instruction으로 넘어가는 명령어이다.  
해당 명령어는 canary의 값을 임의로 대입하는데 이용되는 것 같다.

<img width="846" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/0001820f-f676-456c-9db4-dc08d12ded7b">

2. 이제 하나씩 변수가 저장된 스택프레임을 관찰해보자. 가장 먼저 나오는 어셈블리어를 보면 2byte 크기의 값을 stdin으로 입력받아 buf에 저장되는데 이는 소스 코드의 `read(0, select, 2);` 명령어를 수행하는 어셈블리 코드인 것을 알 수 있고, 따라서 `select` 변수는 `0xffffd40e`에 저장되어있다는 것을 알 수 있다. 그리고 `p/d $ebp -  0xffffd40e` 명령어로 rbp에서 떨어진 위치를 보면 아래와 같이 138만큼 떨어져있다는 것을 알 수 있다.

<img width="846" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/0f08300a-2394-4e97-b44a-cf738a90c3bd">

<img width="639" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/8a4b35a9-8e48-4faf-ab97-ceaec5b9a017">

3. 그리고 순서대로 `select`에 'F\n', 'P\n', 'E\n' 을 대입하며 계속 변수를 찾아보자. 먼저 `F\n`를 입력해서 `box`의 위치를 찾아보면 위처럼 `0xffffd410`에 저장되어 있다는 것을 알 수 있고, 해당 주소는 ebp와 136만큼 떨어져있다는 것을 알 수 있다.
해당 소스코드는 `read(0, box, sizeof(box));`

<img width="824" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/60dd94d2-ec25-4a00-98d6-78ee379a3a49">

<img width="361" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/c14a46de-5f91-4760-bded-44b31a799d0b">

4. 다음은 'P\n' 입력시이다. 먼저 소스코드를 보면 `scanf("%d", &idx);`를 통해 `idx`값을 받는데, 이를 통해 `idx` 변수의 저장 주소를 알 수 있다. 찾은 주소는 `0xffffd404`이며 ebp와는 148만큼 떨어져있다.

<img width="832" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/e9171a10-f637-4705-80f3-7b0da47ec086">

5. 다음은 'E\n' 입력시이다. 소스코드를 보면,   
```
case 'E':
    printf("Name Size : ");
    scanf("%d", &name_len);
    printf("Name : ");
    read(0, name, name_len);
    return 0;
```
에서 처럼 `scanf("%d", &name_len);`로 먼저 `name_len`을 입력받고, `read(0, name, name_len);`로 name_len 만큼 stdin 값을 `name`에 저장한다. 따라서 차례대로 `name_len`과 `name`의 주소를 알 수 있다. 위 스크린샷을 통해 보면, 각각 `0xffffd408`과 `0x0xffffd450`에 저장되어 있다는 것을 알 수 있고, ebp와는 각각 144, 72만큼 떨어져있다.

<img width="838" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/693584c8-3d18-41f8-8500-7f070ceb7297">

<img width="817" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/b9ed1505-da53-4f17-a880-eace7c86dc72">

6. 이제 변수의 주소는 다 찾았기 때문에 마지막으로 canary가 저장된 주소를 찾아봐야한다. x64를 공부하며 canary가 `rbp-0x8`에 저장되어 있길래 x86에서는 `ebp-0x4`에 저장되어 있을 것이라고 당연히 생각해서 이 과정을 건너뛰었었는데, 이것 때문에 익스플로잇에 계속 실패하여 시간을 많이 잡아먹었다. 아래의 스크린샷을 보면 xor으로 `gs:[0x14]`와 `edx == dword ptr[ebp-0x8]`를 `xor`하여 같으면 `<main+345>`로 jump하여 정상종료되기 때문에 `ebp-0x8`에 canary가 저장되어 있다는 것을 알 수 있다.

<img width="1029" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/15a4e186-3585-4a04-87ac-02bc172329b3">

만약 canary가 변조되어 `ebp-0x8`에 저장된 주소가 가리키는 값이 다르다면 아래와 같이 `__stack_chk_failt@plt`로 이동하여 프로그램이 비정상 종료가 된다.

<img width="840" alt="image" src="https://github.com/juhyeongkim527/Dreamhack-Study/assets/138116436/ea082ab2-36ae-46a9-acbf-7859184026b0">
