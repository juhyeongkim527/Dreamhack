# 문제 풀이 방법
```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
void print_box(unsigned char *box, int idx) {
    printf("Element of index %d is : %02x\n", idx, box[idx]);
}
void menu() {
    puts("[F]ill the box");
    puts("[P]rint the box");
    puts("[E]xit");
    printf("> ");
}
int main(int argc, char *argv[]) {
    unsigned char box[0x40] = {};
    char name[0x40] = {};
    char select[2] = {};
    int idx = 0, name_len = 0;
    initialize();
    while(1) {
        menu();
        read(0, select, 2);
        switch( select[0] ) {
            case 'F':
                printf("box input : ");
                read(0, box, sizeof(box));
                break
                case 'P':
                printf("Element index : ");
                scanf("%d", &idx);
                print_box(box, idx);
                break;
            case 'E':
                printf("Name Size : ");
                scanf("%d", &name_len);
                printf("Name : ");
                read(0, name, name_len);
                return 0;
            default:
                break;
        }
    }
}
```

위는 해당 문제의 c 소스코드이다.

코드를 보면 `get_shell()` 함수가 존재하는데 이 함수의 주소를 알아낸 후 `return_address`에 주소를 대입하여 쉘을 획득하는 익스플로잇 방식으로 문제를 풀이하면 될 것이다.

일단 해당 문제는 'i386' 아키텍처를 사용하고, `checksec` 명령어로 파일의 보안 정보를 살펴보면 `Stack Canary found`가 발생하므로,   
익스플로잇 과정에서 canary를 알아내서 값을 그대로 넣어줘야한다. 

그리고 소스코드를 보면 stack에 아래의 변수들이 사용되었는데, 해당 변수들의 위치와 크기를 `gdb`를 통해 파악하며 스택 프레임 구조를 그려봄으로서 canary에 접근할 방법을 찾았다.

- `unsigned char box[0x40] = {};`   : 64byte 크기
- `char name[0x40] = {};`           : 64byte 크기
- `char select[2] = {};`            : 2byte 크기
- `int idx = 0`                     : 4byte 크기 
- `name_len = 0`                    : 4byte 크기

## gdb 실행파일 분석

