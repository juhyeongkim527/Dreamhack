# 문제 설명 및 전체 코드

```
#!/usr/bin/env python3
from flask import Flask, request
import os

app = Flask(__name__)


@app.route('/', methods=['GET'])
def index():
    cmd = request.args.get('cmd', '')
    if not cmd:
        return "?cmd=[cmd]"

    if request.method == 'GET':
        ''
    else:
        os.system(cmd)
    return cmd


app.run(host='0.0.0.0', port=8000)
```

"Read the flag file XD" 라는 설명 이외에 다른 설명이 없는 문제이다. 결국 웹 서버 내에 존재하는 플래그의 위치를 찾아서 읽으면 되는 문제로 보인다.

소스 코드도 매우 짧은 편으로, 간단히 분석해보면 인덱스 페이지에서는 `GET` 메서드를 처리하는 핸들러가 존재한다.

`cmd` 파라미터 값을 받아오는데, 여기서 HTTP 요청이 `GET` 메서드이면 아무 동작을 하지 않은 후 `cmd` 값을 리턴해주고,

HTTP 요청이 다른 메서드이면, `cmd`를 인자로 시스템 함수를 실행한다.

시스템 함수를 실행하여 **Command Injection** 공격을 해야 하는데, 정상적인 `GET` 메서드로는 `cmd` 값을 전달할 수 없기 때문에 이를 우회할 방법을 찾아야 한다.

# 취약점 분석

`GET` 메서드를 우회하여 `cmd` 값을 파라미터로 전달할 방법을 찾기 위해서 생각해보던 중, 하나의 의문이 들었다.

인덱스 페이지의 HTTP 요청을 처리하는 `index()` 핸들러에서 허용하는 메서드가 `GET` 메서드 뿐인데, 어떻게 다른 메서드를 보내서 핸들링할 수 있는지에 대한 의문이었다.

그래서 찾아보니, `flask` 프레임워크에서는 기본적으로 `GET` 핸들러 외에도 `OPTIONS` 또는 `HEAD` 핸들러가 허용된다는 것이었다.

**따라서, 현재 페이지에서 허용되는 HTTP 메서드를 확인할 수 있는 `OPTIONS` 메서드를 통해, 확실히 `/` 엔드포인트에서 어떤 메서드가 사용가능한지 확인해본 후 해당 메서드들을 통해 `GET` 대신 `cmd`를 전달할 방법을 생각해보면 된다.**

참고로, `HEAD` 메서드는 `GET` 메서드와 요청이 거의 동일하지만, `GET` 메서드와 달리 `response`의 본문은 반환하지 않고 헤더만 반환하는 메서드이다.

그럼 이제 `OPTIONS` 메서드를 전달하여, 인덱스 페이지에서 허용되는 메서드들을 확인해볼 방법을 생각해보자.

### 1. `requests` 모듈 사용

파이썬의 `requests` 모듈을 통해 워게임 서버에 `OPTIONS` 요청을 전송한 후, 응답값을 받아오면 된다.

허용 가능한 메서드들은 응답의 헤더에 존재하기 때문에, 아래와 같이 응답값의 헤더에 저장된 `Allow` 필드에서 확인할 수 있다.


헤더를 확인해보면, `OPTIONS`, `GET`, `HEAD` 메서드가 허용된 것을 확인해볼 수 있고, `HEAD` 메서드를 통해 `cmd`를 전달하여 우회하는 방법을 사용하면 되겠다고 설계할 수 있다.

