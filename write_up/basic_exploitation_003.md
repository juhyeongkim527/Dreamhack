# 바이너리 분석

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void alarm_handler()
{
    puts("TIME OUT");
    exit(-1);
}

void initialize()
{
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell()
{
    system("/bin/sh");
}

int main(int argc, char *argv[])
{
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}
```

## 1. Buffer Overflow

해당 바이너리에는 `sprintf(stack_buf, heap_buf);` 라는 코드가 존재한다. 해당 코드의 기본형은 아래와 같다.

- `int sprintf(char *str, const char* format, ...);`

1. `char *str` : 두 번째 인자인 `format`으로 출력된 문자열을 저장할 문자열을 가리키는 포인터 (`format`에 저장된 문자열 자체가 입력되는게 아니라 `format`이 포맷 스트링으로 쓰이기 때문에, 실제로 포맷 스트링으로 인해 출력되는 문자열이 저장)

2. `const char* format` : 포맷 스트링으로 3번째 이후 인자들의 값을 형식 지정자로 가져와서 출력해준다. (인자가 없으면 레지스터, 스택에서 가져오기 때문에 `FSB` 발생 가능)

예를 들어, `int sprintf(stack_buf, heap_buf);` 에서 `heap_buf`가 `"%10c"` 를 가리킨다면, `stack_buf`에는 10개의 공백 문자(`\x20`)이 입력된다.

**여기서 `Buffer Overflow`가 발생할 수 있는 이유는, `stack_buf`의 크기와 상관없이 포맷 스트링으로 인해 출력되는 문자열을 전부 `stack_buf`에 저장하기 때문이다.**

이번 예제에서 `stack_buf`의 크기는 `0x90`인데, `heap_buf`가 `"%1000c"`를 가리킨다면, `0x90`을 넘어서서 `1000`개의 공백을 `stack_buf`의 주소로부터 계속 입력하게 된다.

**이렇게 되면, `stack_buf`의 범위를 넘어서게 되고, `return_address`까지 덮게 되어 `Return Address Overwrite` 공격을 할 수 있게 된다.**

## 2. FSB 

`read(0, heap_buf, 0x80);`를 통해 `sprintf(stack_buf, heap_buf);`의 포맷 스트링으로 사용되는 `heap_buf`에 임의의 문자열을 입력할 수 있게 되는 `FSB` 취약점이 존재한다.

그리고, 문제에서 직접적으로 사용되지는 않지만 `printf("ECHO : %s\n", stack_buf);`에도 `FSB` 취약점이 존재한다. 

`stack_buf`를 `%s`로 출력하긴 하지만, 만약 `stack_buf`에 `%1000c`라는 문자열이 저장되어 있었다면, `%s`를 통해 `%1000c`가 입력되면서, 다시 포맷스트링으로 해석되어 `1000`개의 공백이 출력된다.

# Exploit

## 1. Return Address Overwrite

앞에서 `BOF` 취약점이 존재하기 때문에 `Return Address Overwrite` 공격을 사용할 수 있다. 문제의 바이너리에는 `get_shell()` 함수가 존재하기 때문에 `main`의 `return_address`를 `get_shell`로 덮어주면 쉘을 획득할 수 있을 것이다.

먼저, `get_shell`의 주소는 아래와 같이 구할 수 있다.

![image](https://github.com/user-attachments/assets/e12794a4-590e-4534-b6ca-47753b234ff5)

이후, `stack_buf`와 `return address` 사이의 오프셋을 계산해서, `heap_buf`를 통해 `stack_buf`에 오프셋 만큼의 공백을 채워준 후, `get_shell`의 주소를 출력해서 `return_address`에 `BOF`를 통해 `get_shell`의 주소가 입력되도록 하면 될 것이다.

먼저, `stack_buf`의 위치를 확인하기 위해 `sprintf`가 수행되는 위치에 `breakpoint`를 설정하고 첫번째 인자인 `stack_buf`의 위치를 파악해보자.

<img width="398" alt="image" src="https://github.com/user-attachments/assets/07cbf46d-dcc2-4b22-8884-067fb48db9aa">

위 스크린샷을 보면, 첫번째 인자인 `s`가 저장된 주소가 `0xffffcf90`임을 알 수 있다. `heap_buf`에 `aaaa`를 입력한 후 `sprintf`를 수행한 후 아래와 같이 `esp`를 검사해보면 `esp + 0x8` 위치에 `stack_buf`가 존재한다는 것까지 알 수 있다.

<img width="513" alt="image" src="https://github.com/user-attachments/assets/08bbfd0b-c987-4e84-935c-88a388484a1a">

gdb를 통해 출력되는 주소에서 맨끝이 낮은 주소임을 잘 생각하자.

그럼 이제, `return_address`의 주소를 찾아서 `stack_buf`와의 오프셋을 구해주면 될 것이다. `bt`를 통해 `main`의 `return_address`를 구해도 되고, `gdb`에는 `BACKTRACE` 부분에 `main`의 `return_address`가 나와있다.

<img width="587" alt="image" src="https://github.com/user-attachments/assets/7c875946-04c0-44ca-833f-25c15c376f28">

<img width="526" alt="image" src="https://github.com/user-attachments/assets/966b5ce5-99e5-4e8c-ac26-777f466696ae">

따라서, `return_address`의 주소는 `0xf7da1519`라는 것을 알 수 있고, 이게 `esp`나 `stack_buf`와 얼마나 떨어진 위치에 저장되어 있는지 확인해보면 된다.

`ret`이 수행되기 직전까지 `ni`를 통해 이동해서 `esp`의 상태를 확인해보면, 바로 `[esp]`에 `0xf7da1519`가 존재하는 것을 확인할 수 있고, 해당 위치는 `0xffffd02c` 이다.

그럼 `stack_buf`와의 오프셋을 계산해보면 아래와 같이 `156` 이라는 것을 알 수 있다.

<img width="530" alt="image" src="https://github.com/user-attachments/assets/721443b0-bbf0-4f0d-b6f7-957bc4d50895">

따라서, 이제 `stack_buf`에 `156`개의 공백을 입력해준 후, `get_shell`의 주소를 덮어주면 `RAO` 공격이 가능할 것이다.

## Format String Bug

이제, `stack_buf`에 `156`개의 공백과 `get_shell`의 주소를 어떻게 입력할 수 있는지 살펴보자.

`read(0, heap_buf, 0x80);`로 `heap_buf`에 **`%156c` + `p32(get_shell)`**을 입력해주면, `sprintf(stack_buf, heap_buf);`를 통해 `156`개의 공백이 출력되고, `get_shell`의 주소가 입력될 것이다.

### 주의할 점

처음에, `FSB`를 할 때, `stack_buf`가 `esp + 0x8`에 위치한다는 것을 통해 `%156c%3$n`를 입력해주어서 `stack_buf`에 156개의 공백을 입력해주려고 했다. (사실 생각해보면 `sprintf`가 `stack_buf`에 바로 입력이 되도록 해주기 때문에 이렇게 할 필요가 없긴 하다.)

근데, 이렇게 하면 안되는 이유가 `%n`은 `[esp + 0x__]`에 저장된 값을 주소로 해석해서, 그 주소가 가리키는 값에 현재까지 출력된 문자열의 길이를 대입해준다.

근데, 처음에 `stack_buf`는 전부 `0`으로 초기화되어 있기 때문에 `[esp + 0x8]`에는 `0`이 저장되어 있을 것이고, 이렇게 되면 `0`을 주소값으로 해석해서 `0x0` 번지에 156개의 공백을 입력해주는 것이므로 `SegFault`가 발생한다.

**항상 `%n`은 `[esp + 0x__]`에 저장된 값을 포인터로 해석해서 해당 주소가 가리키는 위치에 현재까지 출력된 문자열의 길이를 대입해준다는 것을 기억하자.**

## Exploit Code

```
from pwn import *

context.arch = "i386"

p = remote("host3.dreamhack.games", 12200)
elf = ELF("./basic_exploitation_003")

get_shell = elf.symbols['get_shell']
# get_shell = 0x8048669

# return_address - &stack_buf = 156
payload = b"%156c"
# payload = b"%156c%3$n"
payload += p32(get_shell)

p.send(payload)
p.interactive()
```






`









